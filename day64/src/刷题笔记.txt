题号：392. 判断子序列
思路：
双指针，长的字符串t，短的字符串s。两个指针i,j分别指向t和s；当i,j指向的元素相等时同时将i,j后移；否在只移动指向长字符串t的指针i。如果最后短字符
串的指针j能移动完整个字符串s，说明s是t的子串
************************************************************************************************************************
题号：104. 二叉树的最大深度
思路：
1、二叉树常规递归
2、类似于层次遍历的BFS，没处理完一层则将答案加一
************************************************************************************************************************
题号：410. 分割数组的最大值
思路：
1、动态规划。dp[i][j]代表将前i个数分成j组时，这j组中和的最大值最小。sub[i]代表前i个数的前缀和。
dp[i][j]=max{dp[k][j-1],sub[i]-sub[k]}，如果dp[i][j]，已经有值了，则dp[i][j]=min{dp[i][j],max{dp[k][j-1],sub[i]-sub[k]}}
已知条件，dp[x][1]=sub[x]，将将前x个数分为1组的值就是前x个数的前缀和
2、二分查找。范围[max(nums),sum(sums)]，即nums元素的最大值和元素的所有和。首先mid=(low+high)/2，遍历数组求和，如果当前和严格大于mid，则
化为一个数组出来，例如temp+=nums[5]后，temp>mid，则此时划分一个数组；之后让temp=nums[5]，重新开始划分数组，保证每个数组的和都不大于mid。
之后，查看划分出来的数组的个数是否大于m，如果大于，说明mid的值太小，low=mid+1；否在说明mid的值太大，high=mid-1。
************************************************************************************************************************
题号：329. 矩阵中的最长递增路径
思路：
DFS+记忆化