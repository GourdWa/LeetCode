题号  146. LRU缓存机制
思路一：利用map存储数据实现put和get功能，同时利用一个deque来维护经常使用的数据的键
思路二：使用哈希表和双链表实现，每次哈希表的键值key，值是双链表。每次put的时候判断哈希表中是否有对应的键存在了，如果有将
原来的值删除，将取出的值更新，并将其移动到双链表表头；如果没有，则创建节点，并放在表头；如果超出容量则删除双链表尾巴节点
每次get的时候，从哈希表中得到一个node，并将该node从双链表中删除，再在头部插入Node。
因为利用双链表进行插入和删除，这样复杂度都是常数级别
************************************************************************************************************************
题号 23 合并k个有序链表
思路一：每次合并两个链表得到一个新链表，下次用新链表去合并下一个链表，时间复杂度高，容易想到
思路二：使用优先队列，对每个链表的每个元素排序，然后依次pop
************************************************************************************************************************

题号 21 合并2个有序链表
思路1：每次合并两个链表得到一个新链表，直接循环拼接即可
思路2：使用递归
递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）
        list1[0]+merge(list1[1:],list2)   list1[0]<list2[0]
        list2[0]+merge(list1,list2[1:])otherwise
如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一
个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。

************************************************************************************************************************
