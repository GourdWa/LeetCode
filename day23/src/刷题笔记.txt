题号 84. 柱状图中最大的矩形
思路 1、递归，每次找到数组中的最小的元素，左边界left，右边界right,此时面积是宽*最小元素（高）；然后下一步以最小元素的下标，
假设为min，在left~min-1范围内，重复上述步骤，此时面积是(min-1-left)*最小元素对应的值；同理在min+1~right范围内重复求解
思路 2、维护两个数组arr1,arr2.arr1中存储了从左到右第一个小于i的数的下标，例如arr1[i]存储的是从i-1往左边扫，第一个小于
heights[i]的数的下标；arr2[i]存储的是从i+1开始往右扫，第一个小于heights[i]的下标。对于arr1[0]=-1;arr2[len-1]=len；
例如heghts={6,7,5,2,4,5,9,3};arr1={-1,0,-1,-1,3,4,5,3};arr2={2,2,3,8,7,7,7,8}。那么此时最大的面积就是arr2[i]-arr1[i]-1再
乘heights[i]
************************************************************************************************************************
题号 28 KMP算法
思路 KMP算法
************************************************************************************************************************
题号 29 不使用乘除取余实现除法运算
思路 1、例如10/3；只需要用10不断的减3，直到差小于3，减的次数就是结果。例如第一次10-3=7；第二次7-3=4；第三次4-3=1<3；
因此结果是3。对于这种运算需要统一符号，即使用绝对值，最后返回结果的时候才加上符号
但是需要注意越界处理，因为Integer.MAX_VALUE的绝对值小于Integer.MIN_VALUE的绝对值，如果被除数是Integer.MIN_VALUE，初始是
任意正数，如果单纯的使用绝对值，Integer.MIN_VALUE的绝对值将会超过int的范围，因此应该将输入的数都转为负数，那么相应的问题
就变成了每次用被除数减除数，如果值小于被除数，则继续，直到值大于被除数。
例如输入10和3，转换为负数，-10和-3.第一次：-10-（-3）=-7<-3，第二次：-7-(-3)=-4<-3;第三次：-4-(-3)=-1>-3.因此结果是3
思路2 类似于二分查找
还是上面的-10和-3
每次不是单纯的减-3，第一次减-3，如果差小于-3；那么第二次减-3<<1，也就是2*-3，此时如果差仍小于2*-3；那么第三次就减-3<<2，
直到差小于-3<<n
while (dividend <= divisor) {
    int temp = divisor;
    int c = 1;
    while (dividend - temp <= temp) {
        temp = temp << 1;
        c = c << 1;
    }
    dividend -= temp;
    result += c;
}

************************************************************************************************************************
