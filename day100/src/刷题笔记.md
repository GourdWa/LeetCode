##### 322. 零钱兑换

1. DFS。不加记忆化是最容易也是最简单的方法，但是中间有大量重复计算，会导致超时
2. DFS+记忆化。记忆化的目的是减少重复计算，用一个一维数组memo[n]来存储计算过的数据，其中memo[i]代表兑换i元需要的最少的零钱个数，memo[0]=0,
   其余元素全部初始化为-2，代表未处理
3. DP。类似于完全背包的处理

---

#####  208. 实现 Trie (前缀树) 

字典树，一种经典的数据结构，用空间换时间

#####  221. 最大正方形

DP。dp[i][j]代表以i,j为右下角的最大的正方形的面积，当matrix[i][j]是，dp[i][j]必然为0；当matrix[i][j]为1时，就需要考虑递推关系，通过画
二维矩阵可以很直观的得出递推关系

#####  84. 柱状图中最大的矩形

单调栈的应用。这里使用的是严格单调递增栈，也就是入栈的元素与栈顶元素比较，如果入栈的元素的值小于等于栈顶元素，那么弹出栈顶元素，直到栈为空或者栈
顶元素小于入栈的元素

#####  85. 最大矩形

动态规划+单调栈。这道题是求矩阵中的最大矩阵，可以利用上一道题的相同的单调栈来解决，不过需要构建好“柱状图”，对于柱状图的构建如下
```text
{{'1', '0', '1', '0', '0'},
{'1', '0', '1', '1', '1'},
{'1', '1', '1', '1', '1'},
{'1', '0', '0', '1', '0'}};
例如上面的矩阵，如果从行看过去，可以看成4个柱状图（分别对应4行），关键是求这4个柱状图的高。
第一行{'1', '0', '1', '0', '0'}的高是【1,0,1,0,0】;
第二行{'1', '0', '1', '1', '1'}的高是在上一行高基础上得出的，如果对应的元素为0，那么高自然为0；
如果对应的元素为1，例如第一个元素，此时对应的高应该是上一行的高加一，因此递推关系如下
heights[i][j] = matrix[i][j] == '1' ? heights[i - 1][j] + 1 : 0;
因此，这个矩阵对应的四个“柱状图”数组如下
[[1,0,1,0,0],
[2,0,2,1,1],
[3,1,3,2,2],
[4,0,0,3,0]]
```
   