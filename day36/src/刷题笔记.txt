1300. 转变数组后最接近目标值的数组和
思路
定义一个变量i=target/arr.length；也就是“均值”。每次遍历数组，求和得到sum；如果target与sum的差的绝对值小于上一次target与sum差的绝对值（用
diff表示），那么更新diff，同时更新答案为i。i进行自增，直到i>=target或者和sum大于等于target
************************************************************************************************************************
复习day1
983. 最低票价
思路
动态规划。列举出365天的消费，如果第i天没有出去旅游，那么第i天的消费就等于第i-1天的消费，即dp[i]=dp[i-1]。dp[i]代表第i天的消费
如果第i天要去旅游，那么此时有三种选择：单独买一天的票，此时dp[i]=dp[i-1]+costs[0]；
前7天买了七天的票，dp[i]=dp[i-7]+costs[1];
前30天买了三十天的票，dp[i]=dp[i-30]+costs[2]
************************************************************************************************************************
1. 两数之和
思路
1、暴力，双重循环
2、哈希表，键为num，值为索引，一次遍历。遍历到num时，判断target-num是否在哈希表中，如果在则说明成功找到；如果不在则将num和其索引放入哈希表，
继续遍历
************************************************************************************************************************
53. 最大子序和
思路
1、贪心算法。定义一个sum=0，每次使nums[i]与sum相加，如果结果大于最大和（ans初始化为nums[0]），则更新；同时判断sum与0的大小，如果小于0则置为0
2、动态规划。动态规划，dp[i]代表以第i个元素结尾包含nums[i]的最大和,可知dp[i]的值取决于前面dp[i-1]的值，dp[i]等于dp[i-1]+nums[i]和nums[i]
之间的较大者
************************************************************************************************************************
2. 两数相加
思路
正常的链表遍历数值相加，注意处理进位就行
