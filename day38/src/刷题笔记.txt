297. 二叉树的序列化与反序列化
思路：
编码，二叉树的非递归前序遍历，不过要将所有的空节点用null表示出来；
解码，根据前序遍历的结果构建树，与大话数据结构不同的是这里不使用全局变量使用队列，每次都poll一个元素，思路与用数组一样
************************************************************************************************************************
1014. 最佳观光组合
思路：
A[i] + i + A[j]- j，j>i
遍历到j时，前面已遍历的元素i+A[i]的值与当前遍历元素A[j]- j的和最大，所以用一个变量preMax存储已经遍历过的元素的A[i]+i的最大值，遍历到元素j的时候就
判断preMax+A[j]- j与ans的大小关系，并判断A[j]+j与preMax的大小，如果前者大则更新preMax0
************************************************************************************************************************
125. 验证回文串
思路：
比较常规的双指针问题，注意细节处理
************************************************************************************************************************
1028. 从先序遍历还原二叉树
思路
这不是常规的先序遍历二叉树，而是将每个节点的深度放在节点值的前面
可知子节点的深度一定大于父节点，因此定义两个成员变量cur和d，cur代表当前字符串的位置，一直递增；d代表将建立节点的深度，使用递归的方法构造树
        private TreeNode dfs(String s, int depth) {
            d = 0;
            int val = 0;
            while (cur < s.length() && s.charAt(cur) != '-') {
                val = val * 10 + s.charAt(cur++) - '0';
            }
            while (cur < s.length() && s.charAt(cur) == '-') {
                d++;
                cur++;
            }
            TreeNode root = new TreeNode(val);
            if (d > depth)
                root.left = dfs(s, d);
            if (d > depth)
                root.right = dfs(s, d);
            return root;
        }